# Create directory and cd into it
mkcd() {
  mkdir -p "$1" && cd "$1" || return
}

# Extract various archive formats
extract() {
  if [ -f "$1" ] ; then
    case "$1" in
      *.tar.bz2)   tar xjf "$1"     ;;
      *.tar.gz)    tar xzf "$1"     ;;
      *.bz2)       bunzip2 "$1"     ;;
      *.rar)       unrar e "$1"     ;;
      *.gz)        gunzip "$1"      ;;
      *.tar)       tar xf "$1"      ;;
      *.tbz2)      tar xjf "$1"     ;;
      *.tgz)       tar xzf "$1"     ;;
      *.zip)       unzip "$1"       ;;
      *.Z)         uncompress "$1"  ;;
      *.7z)        7z x "$1"        ;;
      *)           echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Function to reset ~/.zshrc to the minimal generated sourcing structure
reset_zshrc() {
  local zshrc_file="${HOME}/.zshrc"
  local backup_file="${zshrc_file}_backup_$(date +%Y%m%d_%H%M%S)"
  local sourcing_block_file="${HOME}/.shellx/generated_rc_sourcing.zsh"

  echo "Attempting to reset ${zshrc_file}..."

  # Backup existing file
  if [[ -f "$zshrc_file" ]]; then
    echo "Backing up current ${zshrc_file} to ${backup_file}"
    cp "$zshrc_file" "$backup_file" || {
      echo "Error: Failed to create backup. Aborting." >&2
      return 1
    }
  fi

  # Check if the generated sourcing file exists
  if [[ ! -f "$sourcing_block_file" ]]; then
      echo "Warning: ${sourcing_block_file} not found." >&2
      echo "You may need to run ~/.shellx/generate_rc_sourcing.sh first." >&2
      # Decide if we should proceed without it or abort
      # Let's proceed but generate a minimal fallback .zshrc
      echo "Generating a minimal fallback .zshrc (it might be incomplete)." >&2
  fi

  # Define the minimal content
  local minimal_content
  minimal_content="#!/bin/zsh

# ==== Source Modular Configuration Files ====
# Sources the block generated by ~/.shellx/generate_rc_sourcing.sh

_generated_sourcing_file=\"\${HOME}/.shellx/generated_rc_sourcing.zsh\"
if [[ -f \"\$_generated_sourcing_file\" ]]; then
  source \"\$_generated_sourcing_file\"
else
  # Fallback or error message if generator hasn't run
  printf \"Warning: Could not find generated sourcing file: %s\\n\" \"\$_generated_sourcing_file\" >&2
  printf \"Your Zsh environment might be incomplete. Run ~/.shellx/generate_rc_sourcing.sh\\n\" >&2
  : # No-op
fi
unset _generated_sourcing_file
"

  # Write the minimal content to .zshrc
  echo "Generating new minimal ${zshrc_file}..."
  echo "$minimal_content" > "$zshrc_file" || {
    echo "Error: Failed to write to ${zshrc_file}. Check permissions." >&2
    return 1
  }

  echo "Successfully reset ${zshrc_file}."
  echo "Please start a new shell session or run 'source ~/.zshrc' for changes to take effect."
}

# Function to display help for shellx management commands and list aliases/functions
shellx_help() {
  local shellx_dir="${HOME}/.shellx"
  local alias_file="${shellx_dir}/aliases.zsh"
  local func_file="${shellx_dir}/functions.zsh"

  # --- Management Commands Help --- 
  # Use echo instead of heredoc to avoid quote parsing issues
  echo "Shellx Management Commands:"
  echo ""
  echo "  reset_shellx : Runs all generators and resets ~/.zshrc to the minimal loader."
  echo "                 Backs up existing ~/.zshrc first."
  echo "                 (Runs: ~/.shellx/reset_shellx_setup.sh)"
  echo ""
  echo "  gen_rc       : Regenerates the ~/.shellx/generated_rc_sourcing.zsh file."
  echo "                 Run this if you add/remove/rename .zsh files in ~/.shellx."
  echo "                 (Runs: ~/.shellx/generate_rc_sourcing.sh)"
  echo ""
  echo "  gen_comps    : Regenerates the ~/.shellx/generated_completions.zsh file."
  echo "                 Run this if you add/remove/modify aliases or functions."
  echo "                 (Runs: ~/.shellx/generate_completions.sh)"
  echo ""
  echo "  shellx       : Displays this help message (alias for shellx_help)."
  echo ""
  echo "See ~/.shellx/README.md for more details on the structure."

  # --- List Custom Aliases --- 
  if [[ -f "$alias_file" ]]; then
    echo "\nCustom Aliases (from ${alias_file##*/}):\n"
    # Extract alias names and remove duplicates
    grep -E "^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+=" "$alias_file" | 
      sed -E 's/^[[:space:]]*alias[[:space:]]+([a-zA-Z0-9_-]+)=.*/  \1/' | 
      sort | uniq
  else
    echo "\nAlias file not found: ${alias_file}" >&2
  fi

  # --- List Custom Functions --- 
  if [[ -f "$func_file" ]]; then
    echo "\nCustom Functions (from ${func_file##*/}):\n"
    # Simply grep for function definitions and extract names  
    grep -E "^[a-zA-Z0-9_-]+\\(\\)" "$func_file" | 
      sed -E "s/^([a-zA-Z0-9_-]+).*/  \\1/" | 
      sort
  else
    echo "\nFunction file not found: ${func_file}" >&2
  fi
}

# Activate Python virtual environment without triggering Powerlevel10k warnings
silent_activate() {
  local venv_path="${1:-".venv"}"
  
  # If no argument is provided and .venv exists in current directory, use it
  if [[ $# -eq 0 && -d ".venv" ]]; then
    venv_path=".venv"
  # If no argument is provided and venv exists in current directory, use it
  elif [[ $# -eq 0 && -d "venv" ]]; then
    venv_path="venv"
  fi
  
  # Construct the activate script path
  local activate_script
  if [[ -f "${venv_path}/bin/activate" ]]; then
    activate_script="${venv_path}/bin/activate"
  elif [[ -f "${venv_path}/Scripts/activate" ]]; then
    # For Windows environments
    activate_script="${venv_path}/Scripts/activate"
  else
    echo "Error: Could not find activate script in ${venv_path}"
    return 1
  fi
  
  # Temporarily disable P10K instant prompt warnings
  local old_prompt_setting="${POWERLEVEL9K_INSTANT_PROMPT}"
  export POWERLEVEL9K_INSTANT_PROMPT=quiet
  
  # Source the activate script
  source "${activate_script}"
  
  # Restore the original setting if it existed
  if [[ -n "${old_prompt_setting}" ]]; then
    export POWERLEVEL9K_INSTANT_PROMPT="${old_prompt_setting}"
  else
    unset POWERLEVEL9K_INSTANT_PROMPT
  fi
} 