#!/bin/zsh

# Script to generate Zsh completion definitions for aliases and functions
# defined in the ~/.shellx directory.

setopt errexit
setopt pipefail

local shellx_dir="${HOME}/.shellx"
local alias_file="${shellx_dir}/aliases.zsh"
local func_file="${shellx_dir}/functions.zsh"
local output_file="${shellx_dir}/generated_completions.zsh"
temporary_file=$(mktemp) || exit 1

# Cleanup temporary file on exit
trap 'rm -f "$temporary_file"' EXIT INT TERM HUP

# --- Header for generated file ---
echo "# --- Generated Zsh Completions ---" > "$temporary_file"
echo "# Automatically generated by generate_completions.sh" >> "$temporary_file"
echo "# Source Files: ${alias_file##*/}, ${func_file##*/}" >> "$temporary_file"
echo "# Generated on: $(date)" >> "$temporary_file"
echo "" >> "$temporary_file"

# --- Process Aliases ---
echo "# Completions for Aliases" >> "$temporary_file"
if [[ -f "$alias_file" ]]; then
    # Read line by line, skip comments/empty lines
    grep -E "^\s*alias [a-zA-Z0-9_-]+=" "$alias_file" | while IFS= read -r line; do
        # Extract name: remove 'alias ' prefix, keep only up to '='
        local alias_name=$(echo "$line" | sed -E 's/^\s*alias\s+//; s/=.*//')
        # Extract command: remove 'alias name=', remove surrounding single quotes
        local command_str=$(echo "$line" | sed -E "s/^[^=]+='?//; s/'?$//")
        # Get first word
        local first_word=$(echo "$command_str" | cut -d' ' -f1)
        # Get base command name
        local comp_target=$(basename "$first_word" 2>/dev/null)
        # Handle cases where basename fails or it's a path
        if [[ -z "$comp_target" || "$comp_target" == "$first_word" && "$first_word" == *"/"* ]]; then
             comp_target="$first_word"
        fi
        # If comp_target starts with ~, try expanding it
        if [[ "$comp_target" == "~"* ]]; then
            # Use eval for robust tilde expansion, but be cautious
            eval "expanded_target=$comp_target"
            # Re-run basename on the expanded path
            comp_target=$(basename "$expanded_target" 2>/dev/null)
            if [[ -z "$comp_target" ]]; then 
                 comp_target="$expanded_target" # Fallback to expanded if basename fails
            fi
        fi

        if [[ -n "$alias_name" && -n "$comp_target" ]]; then
            # Basic check if target command likely exists
            if command -v "$comp_target" &>/dev/null || type "$comp_target" &>/dev/null; then
                 echo "compdef _${comp_target} ${alias_name}" >> "$temporary_file"
            else
                 echo "compdef _default ${alias_name}" >> "$temporary_file" # Fallback
            fi
        elif [[ -n "$alias_name" ]]; then
            echo "compdef _default ${alias_name}" >> "$temporary_file" # Fallback
        fi
    done
fi

# --- Process Functions ---
echo "" >> "$temporary_file"
echo "# Completions for Functions" >> "$temporary_file"
if [[ -f "$func_file" ]]; then
    # Extract function names (simple patterns: name() { or function name {)
    grep -E '^[a-zA-Z0-9_-]+\(\)\s*\{|^\s*function\s+[a-zA-Z0-9_-]+\s*\{' "$func_file" |
    sed -E 's/^\s*function\s+//; s/\(\)\s*\{//; s/\s*\{//' |
    while IFS= read -r func_name; do
        if [[ -n "$func_name" ]]; then
            # Remove trailing () if present
            local clean_func_name=$(echo "$func_name" | sed 's/()$//')
            # Use _default completion for functions unless specific logic is added
            echo "compdef _default $clean_func_name" >> "$temporary_file"
        fi
    done
fi

# --- Finalize ---
# Check if the output file exists and if it's different from the new one
if [[ -f "$output_file" ]] && diff -q "$temporary_file" "$output_file" &>/dev/null; then
    echo "Completions in '$output_file' are already up-to-date." >&2
    # rm "$temporary_file" # Temp file removed by trap
    exit 0
else
    echo "Generating/Updating completions file: '$output_file'" >&2
    mv "$temporary_file" "$output_file"
    # Ensure temp file is removed via trap
fi

echo "Completion generation finished." >&2

