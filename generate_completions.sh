#!/bin/zsh

# Script to generate Zsh completion definitions for aliases and functions
# defined in the ~/.shellx directory.

setopt errexit
setopt pipefail

local shellx_dir="${HOME}/.shellx"
local alias_file="${shellx_dir}/aliases.zsh"
local func_file="${shellx_dir}/functions.zsh"
local output_file="${shellx_dir}/generated_completions.zsh"
temporary_file=$(mktemp) || exit 1

# Cleanup temporary file on exit
trap 'rm -f "$temporary_file"' EXIT INT TERM HUP

# --- Header for generated file ---
echo "# --- Generated Zsh Completions ---" > "$temporary_file"
echo "# Automatically generated by generate_completions.sh" >> "$temporary_file"
echo "# Source Files: ${alias_file##*/}, ${func_file##*/}" >> "$temporary_file"
echo "# Generated on: $(date)" >> "$temporary_file"
echo "" >> "$temporary_file"

# --- Process Aliases ---
echo "# Completions for Aliases" >> "$temporary_file"
if [[ -f "$alias_file" ]]; then
    # Extract only alias names without their definitions
    grep -o -E "^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+" "$alias_file" | 
    sed -E 's/^[[:space:]]*alias[[:space:]]+//' |
    sort -u |  # Sort and remove duplicates
    while IFS= read -r alias_name; do
        # Map completions based on the alias name
        case "$alias_name" in
            # VIM-related
            envc|gconf) 
                echo "compdef _vim $alias_name" >> "$temporary_file" ;;
            # Source-related
            envr)
                echo "compdef _source $alias_name" >> "$temporary_file" ;;
            # Directory commands
            ls|l|la|ll|lt|lta|lg)
                if command -v exa &>/dev/null; then
                    echo "compdef _exa $alias_name" >> "$temporary_file"
                else
                    echo "compdef _ls $alias_name" >> "$temporary_file"
                fi
                ;;
            # Git commands
            g|gs|gignore|gwip|grbi|grba|grbc|grbir)
                echo "compdef _git $alias_name" >> "$temporary_file" ;;
            # Basic utils
            grep)
                echo "compdef _grep $alias_name" >> "$temporary_file" ;;
            mkdir)
                echo "compdef _mkdir $alias_name" >> "$temporary_file" ;;
            python)
                echo "compdef _python3 $alias_name" >> "$temporary_file" ;;
            utime)
                echo "compdef _date $alias_name" >> "$temporary_file" ;;
            wrapoff|wrapon)
                echo "compdef _tput $alias_name" >> "$temporary_file" ;;
            tree)
                echo "compdef _tree $alias_name" >> "$temporary_file" ;;
            # MacOS
            hidefiles|showfiles)
                echo "compdef _defaults $alias_name" >> "$temporary_file" ;;
            # Archiving
            tarc|tarx)
                echo "compdef _tar $alias_name" >> "$temporary_file" ;;
            # Default for all others
            *)
                echo "compdef _default $alias_name" >> "$temporary_file" ;;
        esac
    done
fi

# --- Process Functions ---
echo "" >> "$temporary_file"
echo "# Completions for Functions" >> "$temporary_file"
if [[ -f "$func_file" ]]; then
    # Extract function names and remove the parentheses and braces
    grep -E '^[a-zA-Z0-9_-]+\(\)|^\s*function\s+[a-zA-Z0-9_-]+' "$func_file" |
    sed -E 's/^([a-zA-Z0-9_-]+)\(\).*/\1/; s/^\s*function\s+([a-zA-Z0-9_-]+).*/\1/' |
    sort -u | # Sort and remove duplicates
    while IFS= read -r func_name; do
        if [[ -n "$func_name" ]]; then
            # Use _default completion for functions unless specific logic is added
            echo "compdef _default $func_name" >> "$temporary_file"
        fi
    done
fi

# --- Finalize ---
# Check if the output file exists and if it's different from the new one
if [[ -f "$output_file" ]] && diff -q "$temporary_file" "$output_file" &>/dev/null; then
    echo "Completions in '$output_file' are already up-to-date." >&2
    # rm "$temporary_file" # Temp file removed by trap
    exit 0
else
    echo "Generating/Updating completions file: '$output_file'" >&2
    mv "$temporary_file" "$output_file"
    # Ensure temp file is removed via trap
fi

echo "Completion generation finished." >&2

